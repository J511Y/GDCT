package 유준혁;
import java.util.*;
/*
 * r x r 크기 정사각 격자 형태로 된 마을에서 배달원이 물건을 배달하려 합니다. 각 칸은 1 x 1 크기 정사각형이며, 좌측 상단 칸의 좌표는 (0, 0), 우측 하단 칸의 좌표는 (r - 1, r - 1)입니다. 배달원은 처음에 (0, 0) 칸에 있으며, 상, 하, 좌, 우 방향으로 한 칸씩 이동할 수 있습니다. 시각은 0초부터 시작하며, 한 칸 이동하는 데 1초가 걸립니다.

모든 격자 칸에는 물건을 배달해야 하는 집들이 있는데, 각 집마다 물건을 배달할 수 있는 제한 시간이 정해져 있습니다. 만약, 제한 시간 안에 물건을 배달한다면 각 격자 칸마다 정해진 배달 팁을 받을 수 있습니다. 반드시 모든 집에 물건을 배달할 필요는 없지만, 제한시간 안에 물건을 배달하지 못한 집에서는 배달 팁을 받을 수 없습니다. 한 번 지나간 칸을 다시 지나가는 것은 가능하나, 이 경우 제한 시간이 지났거나 이미 배달 팁을 받았다면 다시 배달 팁을 받지는 못합니다. 또, 제한시간이 끝나는 시각과 동시에 배달원이 도착했다면 배달에 성공했다고 가정합니다.

다음은 크기가 3 x 3인 마을의 예시입니다. 괄호 안의 숫자는 (배달 제한 시간, 배달 팁) 순입니다.

deli_3.png

예를 들어 위 마을에서 배달원이 화살표와 같이 이동하면서 물건을 배달했다면 다음과 같이 15원의 배달 팁을 받을 수 있습니다.

시각(초)   배달원 위치   설명
0   (0, 0)   출발 위치에 있는 집에 바로 배달하고 배달 팁 5원을 받습니다.
1   (1, 0)   2초 이전에 도달했으므로 배달 팁 3원을 받습니다.
2   (1, 1)   3초 이전에 도달했으므로 배달 팁 1원을 받습니다.
3   (2, 1)   5초 이전에 도달했으므로 배달 팁 2원을 받습니다.
4   (2, 2)   4초에 정확히 도달했으므로 배달 팁 1원을 받습니다.
5   (1, 2)   3초를 넘어서 도달했으므로 배달 팁을 받을 수 없습니다.
6   (0, 2)   4초를 넘어서 도달했으므로 배달 팁을 받을 수 없습니다.
7   (0, 1)   8초 이전에 도달했으므로 배달 팁 3원을 받습니다.
그러나 아래 그림의 화살표와 같이 배달원이 이동하면서 물건을 배달했다면 17원의 배달 팁을 받을 수 있고, 이때가 최대로 받을 수 있는 배달 팁입니다.

deli_4.png

마을의 크기 r, 각 집의 정해진 배달 시간과 배달 팁이 담긴 2차원 배열 delivery가 매개변수로 주어질 때, 배달원이 최대로 받을 수 있는 배달 팁은 얼마인지 return 하도록 solution 함수를 완성해주세요.

제한사항
r은 2 이상 4 이하인 자연수입니다.
delivery는 세로(행) 길이가 r x r, 가로길이가 2인 2차원 배열입니다.
delivery의 각 행은 각 격자 칸의 [배달 제한 시간, 배달 팁]을 나타냅니다.
i행 j열 칸에 대한 정보는 delivery[i*r + j] 위치에 담겨있습니다.
즉, 길이 r 단위마다 각 행을 나타냅니다.
예를 들어 입출력 예 1번의 경우 2행 1열에 해당하는 데이터는 delivery[2 * 3 + 1] = delivery[7]에 있으며, 이 값은 [제한시간 5초, 배달 팁 2원]을 나타냅니다.
배달 제한 시간은 1 이상 16 이하인 자연수입니다.
배달 팁은 1 이상 100 이하인 자연수입니다.
입출력 예
r   delivery   result
3   [[1, 5],[8, 3],[4, 2],[2, 3],[3, 1],[3, 2],[4, 2],[5, 2],[4, 1]]   17
4   [[1,10],[8, 1],[8, 1],[3, 100],[8, 1],[8, 1],[8, 1],[8, 1],[8, 1],[8, 1],[8, 1],[8, 1],[9, 100],[8, 1],[8, 1],[8, 1]]   217
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

배달 팁을 최대로 받을 수 있는 경로중 하나는 다음과 같습니다.

deli_5.png
 */
public class coupang_1 {
	static int len, max;
	static int[] vst;
	static int[][] del;
	static int[] w = new int[] {1, -1, len, -len};
	static List<Integer> list = new ArrayList<>();
	
	static void dfs(int x, int sum, int time) {
		/// 출력을 위한 list
//		list.add(x);
		vst[x] = 1; // 방문했음을 남김
		if(time == 16) return; // 방문 제한 시간 최대 16
		for(int i = 0; i < 4; i++) {
			int a = x + w[i];
			if(i < 2 && (a / len != x / len)) continue;
			// i < 2 = 좌우로 이동할 경우 인데 1차원배열에서 돌리다보니 가끔 문제가 생기는게 있어서 따로 처리해줌
			// ex) x = 3, i = 1, len = 3일 경우 a = 3 + (-1)이 되는데 원래라면 이동을 못해야하지만 코드상에서는 이동이 가능해져버렸음
			// 그래서 나눈 몫이 같은 경우에만 이동을 하도록 설정
			if(0 <= a && a < (len * len)) { // 범위 내에 들어있는지
				int tmpSum = sum;
				boolean already = vst[a] == 1; // 이미 방문했었는지를 체크해두었다가 vst 갱신할때 쓰임
				if(del[a][0] > time && vst[a] == 0) { // 시간내에 도착 가능하고 아직 방문하지 않은 곳이라면
					tmpSum += del[a][1]; // 팁을 더해줌
					max = Math.max(max, tmpSum); // max값 갱신
					
					/// 출력문
//					list.add(a);
//					System.out.println(list + "\n=>" + tmpSum + "\n");
//					list.remove(list.size() - 1);
				}
				dfs(a, tmpSum, time + 1); // 재귀 실행
				
				/// 출력문
//				list.remove(list.size() - 1);
				
				vst[a] = already ? 1 : 0; // 재귀가 종료됐을때 이전에 이미 방문했던 곳이라면 방문했음을 유지, 아니라면 0으로 바꿔줌.
			}
		}
	}
	static int solution(int r, int delivery[][]) {
		// 초기화
		del = delivery;
		vst = new int[r * r];
		len = r;
		w[2] = len; w[3] = -len;
		max = delivery[0][1];
		
		//재귀 실행
		dfs(0, delivery[0][1], 0);
		return max;
	}
	public static void main(String[] args) {
//		System.out.println(solution(3, new int[][]{{1, 5},{8, 3},{4, 2},{2, 3},{3, 1},{3, 2},{4, 2},{5, 2},{4, 1}} ));
		System.out.println(solution(4, new int[][]
				{{1,10},{8, 1},{8, 1},{3, 100},{8, 1},{8, 1},{8, 1},{8, 1},{8, 1},{8, 1},{8, 1},{8, 1},{9, 100},{8, 1},{8, 1},{8, 1}}
		));
	}
}
